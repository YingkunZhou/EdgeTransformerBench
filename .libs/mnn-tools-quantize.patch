diff --git a/tools/quantization/CMakeLists.txt b/tools/quantization/CMakeLists.txt
index 23c03631..0a911025 100644
--- a/tools/quantization/CMakeLists.txt
+++ b/tools/quantization/CMakeLists.txt
@@ -2,6 +2,11 @@ set(MNN_QUAN_TOOLS "")
 
 file(GLOB QUANFILES ${CMAKE_CURRENT_LIST_DIR}/*.cpp ${CMAKE_CURRENT_LIST_DIR}/*.hpp)
 add_executable(quantized.out ${QUANFILES})
+target_include_directories(quantized.out PRIVATE /usr/include/opencv4)
+target_link_libraries(quantized.out /usr/lib/aarch64-linux-gnu/libopencv_imgproc.so)
+target_link_libraries(quantized.out /usr/lib/aarch64-linux-gnu/libopencv_imgcodecs.so)
+target_link_libraries(quantized.out /usr/lib/aarch64-linux-gnu/libopencv_core.so)
+target_link_libraries(quantized.out /usr/lib/aarch64-linux-gnu/libopencv_dnn.so)
 list(APPEND MNN_QUAN_TOOLS quantized.out)
 
 foreach(TARGET ${MNN_QUAN_TOOLS})
diff --git a/tools/quantization/Helper.cpp b/tools/quantization/Helper.cpp
index 487ebb9b..55b74662 100644
--- a/tools/quantization/Helper.cpp
+++ b/tools/quantization/Helper.cpp
@@ -23,6 +23,7 @@
 #include <sstream>
 #include <string>
 #include "core/TensorUtils.hpp"
+#include "Utils.hpp"
 
 std::set<std::string> Helper::gNotNeedFeatureOp = { "Raster", "Pooling", "ReLU", "ReLU6", "Interp", "CropAndResize", "ROIPooling", "Gather", "GatherV2", "GatherND", "ScatterNd" };
 
@@ -113,6 +114,10 @@ void Helper::readClibrationFiles(std::vector<std::string>& images, const std::st
 
 void Helper::preprocessInput(MNN::CV::ImageProcess* pretreat, PreprocessConfig preprocessConfig, 
                              const std::string& filename, MNN::Tensor* input, InputType inputType) {
+    auto input_tensor = new MNN::Tensor(input, input->getDimensionType());
+    load_image(filename, input_tensor->host<float>(), preprocessConfig.modelName, preprocessConfig.targetWidth, 1);
+    input->copyFromHostTensor(input_tensor);
+    return;
     if (inputType == InputType::IMAGE) {
         int originalWidth, originalHeight, comp;
         auto bitmap32bits = stbi_load(filename.c_str(), &originalWidth, &originalHeight, &comp, 4);
diff --git a/tools/quantization/Helper.hpp b/tools/quantization/Helper.hpp
index 4a6f0670..bd81dd5c 100644
--- a/tools/quantization/Helper.hpp
+++ b/tools/quantization/Helper.hpp
@@ -21,6 +21,7 @@ public:
         int targetWidth;
         float centerCropHeight = 1.0;
         float centerCropWidth = 1.0;
+        std::string modelName;
     };
 
     enum InputType {
diff --git a/tools/quantization/PillowResize.cpp b/tools/quantization/PillowResize.cpp
new file mode 100644
index 00000000..52125f52
--- /dev/null
+++ b/tools/quantization/PillowResize.cpp
@@ -0,0 +1,498 @@
+/*
+* Copyright 2021 Zuru Tech HK Limited
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* istributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#include <utility>
+
+#ifdef _WIN32
+#define _USE_MATH_DEFINES
+#endif
+#include <cmath>
+
+#include "PillowResize.hpp"
+
+double PillowResize::BoxFilter::filter(double x) const
+{
+    constexpr double half_pixel = 0.5;
+    if (x > -half_pixel && x <= half_pixel) {
+        return 1.0;
+    }
+    return 0.0;
+}
+
+double PillowResize::BilinearFilter::filter(double x) const
+{
+    if (x < 0.0) {
+        x = -x;
+    }
+    if (x < 1.0) {
+        return 1.0 - x;
+    }
+    return 0.0;
+}
+
+double PillowResize::HammingFilter::filter(double x) const
+{
+    if (x < 0.0) {
+        x = -x;
+    }
+    if (x == 0.0) {
+        return 1.0;
+    }
+    if (x >= 1.0) {
+        return 0.0;
+    }
+    x = x * M_PI;
+    return sin(x) / x * (0.54 + 0.46 * cos(x));    // NOLINT
+}
+
+double PillowResize::BicubicFilter::filter(double x) const
+{
+    // https://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm
+    constexpr double a = -0.5;
+    if (x < 0.0) {
+        x = -x;
+    }
+    if (x < 1.0) {                                         // NOLINT
+        return ((a + 2.0) * x - (a + 3.0)) * x * x + 1;    // NOLINT
+    }
+    if (x < 2.0) {                                 // NOLINT
+        return (((x - 5) * x + 8) * x - 4) * a;    // NOLINT
+    }
+    return 0.0;
+}
+
+double PillowResize::LanczosFilter::_sincFilter(double x)
+{
+    if (x == 0.0) {
+        return 1.0;
+    }
+    x = x * M_PI;
+    return sin(x) / x;
+}
+
+double PillowResize::LanczosFilter::filter(double x) const
+{
+    // Truncated sinc.
+    // According to Jim Blinn, the Lanczos kernel (with a = 3)
+    // "keeps low frequencies and rejects high frequencies better
+    // than any (achievable) filter we've seen so far."[3]
+    // (https://en.wikipedia.org/wiki/Lanczos_resampling#Advantages)
+    constexpr double lanczos_a_param = 3.0;
+    if (-lanczos_a_param <= x && x < lanczos_a_param) {
+        return _sincFilter(x) * _sincFilter(x / lanczos_a_param);
+    }
+    return 0.0;
+}
+
+int32_t PillowResize::_precomputeCoeffs(int32_t in_size,
+                                        double in0,
+                                        double in1,
+                                        int32_t out_size,
+                                        const std::shared_ptr<Filter>& filterp,
+                                        std::vector<int32_t>& bounds,
+                                        std::vector<double>& kk)
+{
+    // Prepare for horizontal stretch.
+    const double scale = (in1 - in0) / static_cast<double>(out_size);
+    double filterscale = scale;
+    if (filterscale < 1.0) {
+        filterscale = 1.0;
+    }
+
+    // Determine support size (length of resampling filter).
+    const double support = filterp->support() * filterscale;
+
+    // Maximum number of coeffs.
+    const auto k_size = static_cast<int32_t>(ceil(support)) * 2 + 1;
+
+    // Check for overflow
+#if 0
+    if (out_size >
+        INT32_MAX / (k_size * static_cast<int32_t>(sizeof(double)))) {
+        throw std::runtime_error("Memory error");
+    }
+#endif
+
+    // Coefficient buffer.
+    kk.resize(out_size * k_size);
+
+    // Bounds vector.
+    bounds.resize(out_size * 2);
+
+    int32_t x = 0;
+    constexpr double half_pixel = 0.5;
+    for (int32_t xx = 0; xx < out_size; ++xx) {
+        double center = in0 + (xx + half_pixel) * scale;
+        double ww = 0.0;
+        double ss = 1.0 / filterscale;
+        // Round the value.
+        auto xmin = static_cast<int32_t>(center - support + half_pixel);
+        if (xmin < 0) {
+            xmin = 0;
+        }
+        // Round the value.
+        auto xmax = static_cast<int32_t>(center + support + half_pixel);
+        if (xmax > in_size) {
+            xmax = in_size;
+        }
+        xmax -= xmin;
+        double* k = &kk[xx * k_size];
+        for (x = 0; x < xmax; ++x) {
+            double w = filterp->filter((x + xmin - center + half_pixel) * ss);
+            k[x] = w;    // NOLINT
+            ww += w;
+        }
+        for (x = 0; x < xmax; ++x) {
+            if (ww != 0.0) {
+                k[x] /= ww;    // NOLINT
+            }
+        }
+        // Remaining values should stay empty if they are used despite of xmax.
+        for (; x < k_size; ++x) {
+            k[x] = 0;    // NOLINT
+        }
+        bounds[xx * 2 + 0] = xmin;
+        bounds[xx * 2 + 1] = xmax;
+    }
+    return k_size;
+}
+
+std::vector<double> PillowResize::_normalizeCoeffs8bpc(
+    const std::vector<double>& prekk)
+{
+    std::vector<double> kk;
+    kk.reserve(prekk.size());
+
+    constexpr auto shifted_coeff = static_cast<double>(1U << precision_bits);
+
+    constexpr double half_pixel = 0.5;
+    for (const auto& k : prekk) {
+        if (k < 0) {
+            kk.emplace_back(trunc(-half_pixel + k * shifted_coeff));
+        }
+        else {
+            kk.emplace_back(trunc(half_pixel + k * shifted_coeff));
+        }
+    }
+    return kk;
+}
+
+cv::Mat PillowResize::resize(const cv::Mat& src,
+                             const cv::Size& out_size,
+                             int32_t filter)
+{
+    cv::Rect2f box(0.F, 0.F, static_cast<float>(src.size().width),
+                   static_cast<float>(src.size().height));
+    return resize(src, out_size, filter, box);
+}
+
+cv::Mat PillowResize::resize(const cv::Mat& src,
+                             const cv::Size& out_size,
+                             int32_t filter,
+                             const cv::Rect2f& box)
+{
+    // Box = x0,y0,w,h
+    // Rect = x0,y0,x1,y1
+    const cv::Vec4f rect(box.x, box.y, box.x + box.width, box.y + box.height);
+
+    const int32_t x_size = out_size.width;
+    const int32_t y_size = out_size.height;
+#if 0
+    if (x_size < 1 || y_size < 1) {
+        throw std::runtime_error("Height and width must be > 0");
+    }
+
+    if (rect[0] < 0.F || rect[1] < 0.F) {
+        throw std::runtime_error("Box offset can't be negative");
+    }
+
+    if (static_cast<int32_t>(rect[2]) > src.size().width ||
+        static_cast<int32_t>(rect[3]) > src.size().height) {
+        throw std::runtime_error("Box can't exceed original image size");
+    }
+
+    if (box.width < 0 || box.height < 0) {
+        throw std::runtime_error("Box can't be empty");
+    }
+#endif
+
+    // If box's coordinates are int and box size matches requested size
+    if (static_cast<int32_t>(box.width) == x_size &&
+        static_cast<int32_t>(box.height) == y_size) {
+        cv::Rect roi = box;
+        return cv::Mat(src, roi);
+    }
+    if (filter == INTERPOLATION_NEAREST) {
+        return _nearestResample(src, x_size, y_size, rect);
+    }
+    std::shared_ptr<Filter> filter_p;
+
+    // Check filter.
+    switch (filter) {
+        case INTERPOLATION_BOX:
+            filter_p = std::make_shared<BoxFilter>(BoxFilter());
+            break;
+        case INTERPOLATION_BILINEAR:
+            filter_p = std::make_shared<BilinearFilter>(BilinearFilter());
+            break;
+        case INTERPOLATION_HAMMING:
+            filter_p = std::make_shared<HammingFilter>(HammingFilter());
+            break;
+        case INTERPOLATION_BICUBIC:
+            filter_p = std::make_shared<BicubicFilter>(BicubicFilter());
+            break;
+        case INTERPOLATION_LANCZOS:
+            filter_p = std::make_shared<LanczosFilter>(LanczosFilter());
+            break;
+#if 0
+        default:
+            throw std::runtime_error("unsupported resampling filter");
+#endif
+    }
+
+    return PillowResize::_resample(src, x_size, y_size, filter_p, rect);
+}
+
+cv::Mat PillowResize::_nearestResample(const cv::Mat& im_in,
+                                       int32_t x_size,
+                                       int32_t y_size,
+                                       const cv::Vec4f& rect)
+{
+    auto rx0 = static_cast<int32_t>(rect[0]);
+    auto ry0 = static_cast<int32_t>(rect[1]);
+    auto rx1 = static_cast<int32_t>(rect[2]);
+    auto ry1 = static_cast<int32_t>(rect[3]);
+    rx0 = std::max(rx0, 0);
+    ry0 = std::max(ry0, 0);
+    rx1 = std::min(rx1, im_in.size().width);
+    ry1 = std::min(ry1, im_in.size().height);
+
+    // Affine tranform matrix.
+    cv::Mat m = cv::Mat::zeros(2, 3, CV_64F);
+    m.at<double>(0, 0) =
+        static_cast<double>(rx1 - rx0) / static_cast<double>(x_size);
+    m.at<double>(0, 2) = static_cast<double>(rx0);
+    m.at<double>(1, 1) =
+        static_cast<double>(ry1 - ry0) / static_cast<double>(y_size);
+    m.at<double>(1, 2) = static_cast<double>(ry0);
+
+    cv::Mat im_out = cv::Mat::zeros(y_size, x_size, im_in.type());
+
+    // Check pixel type and determine the pixel size
+    // (element size * number of channels).
+    size_t pixel_size = 0;
+    switch (_getPixelType(im_in)) {
+        case CV_8U:
+            pixel_size = sizeof(uint8_t);
+            break;
+        case CV_8S:
+            pixel_size = sizeof(int8_t);
+            break;
+        case CV_16U:
+            pixel_size = sizeof(uint16_t);
+            break;
+        case CV_16S:
+            pixel_size = sizeof(int16_t);
+            break;
+        case CV_32S:
+            pixel_size = sizeof(int32_t);
+            break;
+        case CV_32F:
+            pixel_size = sizeof(float);
+            break;
+#if 0
+        default:
+            throw std::runtime_error("Pixel type not supported");
+#endif
+    }
+    pixel_size *= im_in.channels();
+
+    const int32_t x0 = 0;
+    const int32_t y0 = 0;
+    const int32_t x1 = x_size;
+    const int32_t y1 = y_size;
+
+    double xo = m.at<double>(0, 2) + m.at<double>(0, 0) * 0.5;
+    double yo = m.at<double>(1, 2) + m.at<double>(1, 1) * 0.5;
+
+    auto coord = [](double x) -> int32_t {
+        return x < 0. ? -1 : static_cast<int32_t>(x);
+    };
+
+    std::vector<int> xintab;
+    xintab.resize(im_out.size().width);
+
+    /* Pretabulate horizontal pixel positions */
+    int32_t xmin = x1;
+    int32_t xmax = x0;
+    for (int32_t x = x0; x < x1; ++x) {
+        int32_t xin = coord(xo);
+        if (xin >= 0 && xin < im_in.size().width) {
+            xmax = x + 1;
+            if (x < xmin) {
+                xmin = x;
+            }
+            xintab[x] = xin;
+        }
+        xo += m.at<double>(0, 0);
+    }
+
+    for (int32_t y = y0; y < y1; ++y) {
+        int32_t yi = coord(yo);
+        if (yi >= 0 && yi < im_in.size().height) {
+            for (int32_t x = xmin; x < xmax; ++x) {
+                memcpy(im_out.ptr(y, x), im_in.ptr(yi, xintab[x]), pixel_size);
+            }
+        }
+        yo += m.at<double>(1, 1);
+    }
+
+    return im_out;
+}
+
+cv::Mat PillowResize::_resample(const cv::Mat& im_in,
+                                int32_t x_size,
+                                int32_t y_size,
+                                const std::shared_ptr<Filter>& filter_p,
+                                const cv::Vec4f& rect)
+{
+    cv::Mat im_out;
+    cv::Mat im_temp;
+
+    std::vector<int32_t> bounds_horiz;
+    std::vector<int32_t> bounds_vert;
+    std::vector<double> kk_horiz;
+    std::vector<double> kk_vert;
+
+    const bool need_horizontal = x_size != im_in.size().width ||
+                                 (rect[0] != 0.0F) ||
+                                 static_cast<int32_t>(rect[2]) != x_size;
+    const bool need_vertical = y_size != im_in.size().height ||
+                               (rect[1] != 0.0F) ||
+                               static_cast<int32_t>(rect[3]) != y_size;
+
+    // Compute horizontal filter coefficients.
+    const int32_t ksize_horiz =
+        _precomputeCoeffs(im_in.size().width, rect[0], rect[2], x_size,
+                          filter_p, bounds_horiz, kk_horiz);
+
+    // Compute vertical filter coefficients.
+    const int32_t ksize_vert =
+        _precomputeCoeffs(im_in.size().height, rect[1], rect[3], y_size,
+                          filter_p, bounds_vert, kk_vert);
+
+    // First used row in the source image.
+    const int32_t ybox_first = bounds_vert[0];
+    // Last used row in the source image.
+    const int32_t ybox_last =
+        bounds_vert[y_size * 2 - 2] + bounds_vert[y_size * 2 - 1];
+
+    // Two-pass resize, horizontal pass.
+    if (need_horizontal) {
+        // Shift bounds for vertical pass.
+        for (int32_t i = 0; i < y_size; ++i) {
+            bounds_vert[i * 2] -= ybox_first;
+        }
+
+        // Create destination image with desired ouput width and same input pixel type.
+        im_temp.create(ybox_last - ybox_first, x_size, im_in.type());
+        if (!im_temp.empty()) {
+            _resampleHorizontal(im_temp, im_in, ybox_first, ksize_horiz,
+                                bounds_horiz, kk_horiz);
+        }
+        else {
+            return cv::Mat();
+        }
+        im_out = im_temp;
+    }
+
+    // Vertical pass.
+    if (need_vertical) {
+        // Create destination image with desired ouput size and same input pixel type.
+
+        const auto new_w =
+            (im_temp.size().width != 0) ? im_temp.size().width : x_size;
+        im_out.create(y_size, new_w, im_in.type());
+        if (!im_out.empty()) {
+            if (im_temp.empty()) {
+                im_temp = im_in;
+            }
+            // Input can be the original image or horizontally resampled one.
+            _resampleVertical(im_out, im_temp, ksize_vert, bounds_vert,
+                              kk_vert);
+        }
+        else {
+            return cv::Mat();
+        }
+    }
+
+    // None of the previous steps are performed, copying.
+    if (im_out.empty()) {
+        im_out = im_in;
+    }
+
+    return im_out;
+}
+
+void PillowResize::_resampleHorizontal(cv::Mat& im_out,
+                                       const cv::Mat& im_in,
+                                       int32_t offset,
+                                       int32_t ksize,
+                                       const std::vector<int32_t>& bounds,
+                                       const std::vector<double>& prekk)
+{
+    // Check pixel type.
+    switch (_getPixelType(im_in)) {
+        case CV_8U:
+            return _resampleHorizontal<uint8_t>(
+                im_out, im_in, offset, ksize, bounds, prekk,
+                _normalizeCoeffs8bpc,
+                static_cast<double>(1U << (precision_bits - 1U)), _clip8);
+        case CV_8S:
+            return _resampleHorizontal<int8_t>(im_out, im_in, offset, ksize,
+                                               bounds, prekk, nullptr, 0.,
+                                               _roundUp<int8_t>);
+        case CV_16U:
+            return _resampleHorizontal<uint16_t>(im_out, im_in, offset, ksize,
+                                                 bounds, prekk);
+        case CV_16S:
+            return _resampleHorizontal<int16_t>(im_out, im_in, offset, ksize,
+                                                bounds, prekk, nullptr, 0.,
+                                                _roundUp<int16_t>);
+        case CV_32S:
+            return _resampleHorizontal<int32_t>(im_out, im_in, offset, ksize,
+                                                bounds, prekk, nullptr, 0.,
+                                                _roundUp<int32_t>);
+        case CV_32F:
+            return _resampleHorizontal<float>(im_out, im_in, offset, ksize,
+                                              bounds, prekk);
+#if 0
+        default:
+            throw std::runtime_error("Pixel type not supported");
+#endif
+    }
+}
+
+void PillowResize::_resampleVertical(cv::Mat& im_out,
+                                     const cv::Mat& im_in,
+                                     int32_t ksize,
+                                     const std::vector<int32_t>& bounds,
+                                     const std::vector<double>& prekk)
+{
+    im_out = im_out.t();
+    _resampleHorizontal(im_out, im_in.t(), 0, ksize, bounds, prekk);
+    im_out = im_out.t();
+}
diff --git a/tools/quantization/PillowResize.hpp b/tools/quantization/PillowResize.hpp
new file mode 100644
index 00000000..f07d7297
--- /dev/null
+++ b/tools/quantization/PillowResize.hpp
@@ -0,0 +1,458 @@
+/*
+* Copyright 2021 Zuru Tech HK Limited
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* istributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#ifndef PILLOWRESIZE_HPP
+#define PILLOWRESIZE_HPP
+
+#include <array>
+#include <cstdint>
+#include <limits>
+#include <memory>
+#include <vector>
+
+#ifdef _WIN32
+#define _USE_MATH_DEFINES
+#endif
+#include <cmath>
+
+#include <opencv2/imgcodecs.hpp>
+#include <opencv2/imgproc.hpp>
+
+/**
+ * \brief PillowResize Porting of the resize methods from Pillow library
+ * (https://github.com/python-pillow/Pillow).
+ * The implementation depends only on OpenCV, so all Pillow code has been
+ * converted to use cv::Mat and OpenCV structures.
+ * Since Pillow does not support natively all cv::Mat types, this implementation
+ * extends the support to almost all OpenCV pixel types.
+ */
+class PillowResize {
+protected:
+    /**
+     * \brief precision_bits 8 bits for result. Filter can have negative areas.
+     * In one case the sum of the coefficients will be negative,
+     * in the other it will be more than 1.0. That is why we need
+     * two extra bits for overflow and int type.
+     */
+    static constexpr uint32_t precision_bits = 32 - 8 - 2;
+
+    static constexpr double box_filter_support = 0.5;
+    static constexpr double bilinear_filter_support = 1.;
+    static constexpr double hamming_filter_support = 1.;
+    static constexpr double bicubic_filter_support = 2.;
+    static constexpr double lanczos_filter_support = 3.;
+
+    /**
+     * \brief Filter Abstract class to handle the filters used by
+     * the different interpolation methods.
+     */
+    class Filter {
+    private:
+        double _support; /** Support size (length of resampling filter). */
+
+    public:
+        /**
+         * \brief Construct a new Filter object.
+         *
+         * \param[in] support Support size (length of resampling filter).
+         */
+        explicit Filter(double support) : _support{support} {};
+
+        /**
+         * \brief filter Apply filter.
+         *
+         * \param[in] x Input value.
+         *
+         * \return Processed value by the filter.
+         */
+        [[nodiscard]] virtual double filter(double x) const = 0;
+
+        /**
+         * \brief support Get support size.
+         *
+         * \return support size.
+         */
+        [[nodiscard]] double support() const { return _support; };
+    };
+
+    class BoxFilter : public Filter {
+    public:
+        BoxFilter() : Filter(box_filter_support){};
+        [[nodiscard]] double filter(double x) const override;
+    };
+
+    class BilinearFilter : public Filter {
+    public:
+        BilinearFilter() : Filter(bilinear_filter_support){};
+        [[nodiscard]] double filter(double x) const override;
+    };
+
+    class HammingFilter : public Filter {
+    public:
+        HammingFilter() : Filter(hamming_filter_support){};
+        [[nodiscard]] double filter(double x) const override;
+    };
+
+    class BicubicFilter : public Filter {
+    public:
+        BicubicFilter() : Filter(bicubic_filter_support){};
+        [[nodiscard]] double filter(double x) const override;
+    };
+
+    class LanczosFilter : public Filter {
+    protected:
+        [[nodiscard]] static double _sincFilter(double x);
+
+    public:
+        LanczosFilter() : Filter(lanczos_filter_support){};
+        [[nodiscard]] double filter(double x) const override;
+    };
+
+#if __cplusplus >= 201703L
+    /**
+     * \brief _lut Generate lookup table.
+     * \reference https://joelfilho.com/blog/2020/compile_time_lookup_tables_in_cpp/
+     *
+     * \tparam Length Number of table elements.
+     * \param[in] f Functor called to generate each elements in the table.
+     *
+     * \return An array of length Length with type deduced from Generator output.
+     */
+    template <size_t Length, typename Generator>
+    static constexpr auto _lut(Generator&& f)
+    {
+        using content_type = decltype(f(size_t{0}));
+        std::array<content_type, Length> arr{};
+        for (size_t i = 0; i < Length; ++i) {
+            arr[i] = f(i);
+        }
+        return arr;
+    }
+
+    /**
+     * \brief _clip8_lut Clip lookup table.
+     *
+     * \tparam Length Number of table elements.
+     * \tparam min_val Value of the starting element.
+     */
+    template <size_t Length, intmax_t min_val>
+    static inline constexpr auto _clip8_lut =
+        _lut<Length>([](size_t n) -> uint8_t {
+            intmax_t saturate_val = static_cast<intmax_t>(n) + min_val;
+            if (saturate_val < 0) {
+                return 0;
+            }
+            if (saturate_val > UINT8_MAX) {
+                return UINT8_MAX;
+            }
+            return static_cast<uint8_t>(saturate_val);
+        });
+#endif
+
+    /**
+     * \brief _clip8 Optimized clip function.
+     *
+     * \param[in] in input value.
+     *
+     * \return Clipped value.
+     */
+    [[nodiscard]] static uint8_t _clip8(double in)
+    {
+#if __cplusplus >= 201703L
+        // Lookup table to speed up clip method.
+        // Handles values from -640 to 639.
+        const uint8_t* clip8_lookups =
+            &_clip8_lut<1280, -640>[640];    // NOLINT
+        // NOLINTNEXTLINE
+        return clip8_lookups[static_cast<intmax_t>(in) >> precision_bits];
+#else
+        auto saturate_val = static_cast<intmax_t>(in) >> precision_bits;
+        if (saturate_val < 0) {
+            return 0;
+        }
+        if (saturate_val > UINT8_MAX) {
+            return UINT8_MAX;
+        }
+        return static_cast<uint8_t>(saturate_val);
+#endif
+    }
+
+    /**
+     * \brief _roundUp Round function.
+     * The output value will be cast to type T.
+     *
+     * \param[in] f Input value.
+     *
+     * \return Rounded value.
+     */
+    template <typename T>
+    [[nodiscard]] static T _roundUp(double f)
+    {
+        return static_cast<T>(std::round(f));
+    }
+
+    /**
+     * \brief _getPixelType Return the type of a matrix element.
+     * If the matrix has multiple channels, the function returns the
+     * type of the element without the channels.
+     * For instance, if the type is CV_16SC3 the function return CV_16S.
+     *
+     * \param[in] img Input image.
+     *
+     * \return Matrix element type.
+     */
+    [[nodiscard]] static int32_t _getPixelType(const cv::Mat& img)
+    {
+        return img.type() & CV_MAT_DEPTH_MASK;    // NOLINT
+    }
+
+    /**
+     * \brief _precomputeCoeffs Compute 1D interpolation coefficients.
+     * If you have an image (or a 2D matrix), call the method twice to compute
+     * the coefficients for row and column either.
+     * The coefficients are computed for each element in range [0, out_size).
+     *
+     * \param[in] in_size Input size (e.g. image width or height).
+     * \param[in] in0 Input starting index.
+     * \param[in] in1 Input last index.
+     * \param[in] out_size Output size.
+     * \param[in] filterp Pointer to a Filter object.
+     * \param[out] bounds Bounds vector. A bound is a pair of xmin and xmax.
+     * \param[out] kk Coefficients vector. To each elements corresponds a number of
+     * coefficients returned by the function.
+     *
+     * \return Size of the filter coefficients.
+     */
+    [[nodiscard]] static int32_t _precomputeCoeffs(
+        int32_t in_size,
+        double in0,
+        double in1,
+        int32_t out_size,
+        const std::shared_ptr<Filter>& filterp,
+        std::vector<int32_t>& bounds,
+        std::vector<double>& kk);
+
+    /**
+     * \brief _normalizeCoeffs8bpc Normalize coefficients for 8 bit per pixel matrix.
+     *
+     * \param[in] prekk Filter coefficients.
+     *
+     * \return Filter coefficients normalized.
+     */
+    [[nodiscard]] static std::vector<double> _normalizeCoeffs8bpc(
+        const std::vector<double>& prekk);
+
+    /**
+     * \brief _resampleHorizontal Apply resample along the horizontal axis.
+     * It calls the _resampleHorizontal with the correct pixel type using
+     * the value returned by cv::Mat::type().
+     *
+     * \param[in, out] im_out Output resized matrix.
+     *                        The matrix has to be previously initialized with right size.
+     * \param[in] im_in Input matrix.
+     * \param[in] offset Vertical offset (first used row in the source image).
+     * \param[in] ksize Interpolation filter size.
+     * \param[in] bounds Interpolation filter bounds (value of the min and max column
+     *                   to be considered by the filter).
+     * \param[in] prekk Interpolation filter coefficients.
+     */
+    static void _resampleHorizontal(cv::Mat& im_out,
+                                    const cv::Mat& im_in,
+                                    int32_t offset,
+                                    int32_t ksize,
+                                    const std::vector<int32_t>& bounds,
+                                    const std::vector<double>& prekk);
+
+    /**
+     * \brief _resampleVertical Apply resample along the vertical axis.
+     * It calls the _resampleVertical with the correct pixel type using
+     * the value returned by cv::Mat::type().
+     *
+     * \param[in, out] im_out Output resized matrix.
+     *                        The matrix has to be previously initialized with right size.
+     * \param[in] im_in Input matrix.
+     * \param[in] ksize Interpolation filter size.
+     * \param[in] bounds Interpolation filter bounds (value of the min and max row
+     *                   to be considered by the filter).
+     * \param[in] prekk Interpolation filter coefficients.
+     */
+    static void _resampleVertical(cv::Mat& im_out,
+                                  const cv::Mat& im_in,
+                                  int32_t ksize,
+                                  const std::vector<int32_t>& bounds,
+                                  const std::vector<double>& prekk);
+
+    using preprocessCoefficientsFn =
+        std::vector<double> (*)(const std::vector<double>&);
+
+    template <typename T>
+    using outMapFn = T (*)(double);
+
+    /**
+     * \brief _resampleHorizontal Apply resample along the horizontal axis.
+     *
+     * \param[in, out] im_out Output resized matrix.
+     *                       The matrix has to be previously initialized with right size.
+     * \param[in] im_in Input matrix.
+     * \param[in] offset Vertical offset (first used row in the source image).
+     * \param[in] ksize Interpolation filter size.
+     * \param[in] bounds Interpolation filter bounds (index of min and max pixel
+     *                   to be considered by the filter).
+     * \param[in] prekk Interpolation filter coefficients.
+     * \param[in] preprocessCoefficients Function used to process the filter coefficients.
+     * \param[in] init_buffer Initial value of pixel buffer (default: 0.0).
+     * \param[in] outMap Function used to convert the value of the pixel after
+     *                   the interpolation into the output pixel.
+     */
+    template <typename T>
+    static void _resampleHorizontal(
+        cv::Mat& im_out,
+        const cv::Mat& im_in,
+        int32_t offset,
+        int32_t ksize,
+        const std::vector<int32_t>& bounds,
+        const std::vector<double>& prekk,
+        preprocessCoefficientsFn preprocessCoefficients = nullptr,
+        double init_buffer = 0.,
+        outMapFn<T> outMap = nullptr);
+
+    /**
+     * \brief _resample Resize a matrix using the specified interpolation method.
+     *
+     * \param[in] im_in Input matrix.
+     * \param[in] x_size Desidered output width.
+     * \param[in] y_size Desidered output height.
+     * \param[in] filter_p Pointer to the interpolation filter.
+     * \param[in] rect Input region that has to be resized.
+     *                 Region is defined as a vector of 4 point x0,y0,x1,y1.
+     *
+     * \return Resized matrix. The type of the matrix will be the same of im_in.
+     */
+    [[nodiscard]] static cv::Mat _resample(
+        const cv::Mat& im_in,
+        int32_t x_size,
+        int32_t y_size,
+        const std::shared_ptr<Filter>& filter_p,
+        const cv::Vec4f& rect);
+
+    /**
+     * \brief _nearestResample Resize a matrix using nearest neighbor interpolation.
+     *
+     * \param[in] im_in Input matrix.
+     * \param[in] x_size Desidered output width.
+     * \param[in] y_size Desidered output height.
+     * \param[in] rect Input region that has to be resized.
+     *                 Region is defined as a vector of 4 point x0,y0,x1,y1.
+     *
+     * \return Resized matrix. The type of the matrix will be the same of im_in.
+     *
+     * \throws std::runtime_error If the input matrix type is not supported.
+     */
+    [[nodiscard]] static cv::Mat _nearestResample(const cv::Mat& im_in,
+                                                  int32_t x_size,
+                                                  int32_t y_size,
+                                                  const cv::Vec4f& rect);
+
+public:
+    /**
+     * \brief InterpolationMethods Interpolation methods.
+     *
+     * \see https://pillow.readthedocs.io/en/stable/handbook/concepts.html#concept-filters.
+     */
+    enum InterpolationMethods {
+        INTERPOLATION_NEAREST = 0,
+        INTERPOLATION_BOX = 4,
+        INTERPOLATION_BILINEAR = 2,
+        INTERPOLATION_HAMMING = 5,
+        INTERPOLATION_BICUBIC = 3,
+        INTERPOLATION_LANCZOS = 1,
+    };
+
+    /**
+     * \brief resize Porting of Pillow resize method.
+     *
+     * \param[in] src Input matrix that has to be processed.
+     * \param[in] out_size Output matrix size.
+     * \param[in] filter Interpolation method code, see InterpolationMethods.
+     * \param[in] box Input roi. Only the elements inside the box will be resized.
+     *
+     * \return Resized matrix.
+     *
+     * \throw std::runtime_error In case the box is invalid, the interpolation filter
+     *        or the input matrix type are not supported.
+     */
+    [[nodiscard]] static cv::Mat resize(const cv::Mat& src,
+                                        const cv::Size& out_size,
+                                        int32_t filter,
+                                        const cv::Rect2f& box);
+
+    /**
+     * \brief resize Porting of Pillow resize method.
+     *
+     * \param[in] src Input matrix that has to be processed.
+     * \param[in] out_size Output matrix size.
+     * \param[in] filter Interpolation method code, see interpolation enum.
+     *
+     * \return Resized matrix.
+     *
+     * \throw std::runtime_error In case the box is invalid, the interpolation filter
+     *        or the input matrix type are not supported.
+     */
+    [[nodiscard]] static cv::Mat resize(const cv::Mat& src,
+                                        const cv::Size& out_size,
+                                        int32_t filter);
+};
+
+template <typename T>
+void PillowResize::_resampleHorizontal(
+    cv::Mat& im_out,
+    const cv::Mat& im_in,
+    int32_t offset,
+    int32_t ksize,
+    const std::vector<int32_t>& bounds,
+    const std::vector<double>& prekk,
+    preprocessCoefficientsFn preprocessCoefficients,
+    double init_buffer,
+    outMapFn<T> outMap)
+{
+    std::vector<double> kk(prekk.begin(), prekk.end());
+    // Preprocess coefficients if needed.
+    if (preprocessCoefficients != nullptr) {
+        kk = preprocessCoefficients(kk);
+    }
+
+    for (int32_t yy = 0; yy < im_out.size().height; ++yy) {
+        for (int32_t xx = 0; xx < im_out.size().width; ++xx) {
+            const int32_t xmin = bounds[xx * 2 + 0];
+            const int32_t xmax = bounds[xx * 2 + 1];
+            const double* k = &kk[xx * ksize];
+            for (int32_t c = 0; c < im_in.channels(); ++c) {
+                double ss = init_buffer;
+                for (int32_t x = 0; x < xmax; ++x) {
+                    // NOLINTNEXTLINE
+                    ss += static_cast<double>(
+                              im_in.ptr<T>(yy + offset, x + xmin)[c]) *
+                          k[x];
+                }
+                // NOLINTNEXTLINE
+                im_out.ptr<T>(yy, xx)[c] =
+                    (outMap == nullptr ? static_cast<T>(ss) : outMap(ss));
+            }
+        }
+    }
+}
+
+#endif
diff --git a/tools/quantization/Utils.cpp b/tools/quantization/Utils.cpp
new file mode 100644
index 00000000..2853d9bc
--- /dev/null
+++ b/tools/quantization/Utils.cpp
@@ -0,0 +1,112 @@
+
+#include <opencv2/dnn/dnn.hpp>
+#include <opencv2/imgcodecs.hpp>
+#include <opencv2/imgproc.hpp>
+#include "PillowResize.hpp"
+
+#include <iostream>
+#include <numeric>
+#include <string>
+#include <vector>
+#include <iomanip>
+#include "Utils.hpp"
+
+void pre_process(cv::Mat& img, std::string model, int input_size) {
+    bool is_resnet50  = model.find("resnet50") != std::string::npos;
+    bool is_edgenext  = model.find("edgenext") != std::string::npos;
+    bool is_edgenext_small = model.find("edgenext_small") != std::string::npos;
+    bool is_mobilevit = model.find("mobilevit") != std::string::npos;
+    bool is_efficientnetv2_b3 = model.find("efficientnetv2_b3") != std::string::npos;
+
+    int size;
+    double crop_pct;
+
+    if (is_resnet50 ||  is_edgenext_small) { // for EdgeNeXt
+        crop_pct = 0.95;
+        size = int(input_size / crop_pct);
+    }
+    else if (is_edgenext) {
+        crop_pct = 224.f / 256.f;
+        size = int(input_size / crop_pct);
+    }
+    else {
+        size = input_size + 32;
+    }
+
+    int width  = img.cols;
+    int height = img.rows;
+    if (width > height) {
+        width = size * width / height;
+        height = size;
+    }
+    else {
+        height = size * height / width;
+        width = size;
+    }
+
+    // transforms.Resize(size, interpolation=transforms.InterpolationMode.BICUBIC)
+    /* https://github.com/python-pillow/Pillow/issues/2718
+       but has difference with python pillow
+       https://github.com/zurutech/pillow-resize
+    */
+    // cv::resize(img, img, cv::Size(width, height), cv::InterpolationFlags::INTER_CUBIC);
+    img = PillowResize::resize(img, cv::Size(width, height), PillowResize::INTERPOLATION_BICUBIC);
+
+    // std::cout << img.at<cv::Vec3b>(112,112) << std::endl;
+    // transforms.CenterCrop(args.input_size)
+    // https://gist.github.com/1duo/c868f0bccf0d1f6cd8b36086ba295e04
+    int offW = (img.cols - input_size) / 2;
+    int offH = (img.rows - input_size) / 2;
+    const cv::Rect roi(offW, offH, input_size, input_size);
+    img = img(roi);
+
+    // transforms.ToTensor()
+    img.convertTo(img, CV_32F, 1.f / 255.f);
+
+    if (is_mobilevit) {
+        cv::dnn::blobFromImage(img, img);
+        return;
+    }
+    // transforms.Normalize(IMAGENET_DEFAULT_MEAN, IMAGENET_DEFAULT_STD)
+    cv::Mat channels[3];
+    cv::split(img, channels);
+    /* Normalization per channel
+       Normalization parameters obtained from
+       https://github.com/onnx/models/tree/master/vision/classification/squeezenet
+    */
+    if (is_efficientnetv2_b3) {
+        channels[0] = (channels[0] - 0.5) / 0.5;
+        channels[1] = (channels[1] - 0.5) / 0.5;
+        channels[2] = (channels[2] - 0.5) / 0.5;
+    }
+    else {
+        channels[0] = (channels[0] - IMAGENET_DEFAULT_MEAN[0]) / IMAGENET_DEFAULT_STD[0];
+        channels[1] = (channels[1] - IMAGENET_DEFAULT_MEAN[1]) / IMAGENET_DEFAULT_STD[1];
+        channels[2] = (channels[2] - IMAGENET_DEFAULT_MEAN[2]) / IMAGENET_DEFAULT_STD[2];
+    }
+    cv::merge(channels, 3, img);
+
+    // HWC to CHW
+    cv::dnn::blobFromImage(img, img);
+}
+
+void load_image(
+    const std::string& img_path,
+    float *input_tensor,
+    std::string model,
+    int input_size,
+    int batch_size)
+{
+    // read img and pre-process
+    cv::Mat img = cv::imread(img_path, cv::IMREAD_COLOR);
+    if (model.find("mobilevit_") == std::string::npos) {
+        cv::cvtColor(img, img, cv::COLOR_BGR2RGB);
+    }
+    pre_process(img, model, input_size);
+    // Make copies of the same image input.
+    for (int64_t i = 0; i < batch_size; ++i)
+    {
+        std::copy(img.begin<float>(), img.end<float>(),
+        input_tensor + i * 3 * input_size * input_size);
+    }
+}
\ No newline at end of file
diff --git a/tools/quantization/Utils.hpp b/tools/quantization/Utils.hpp
new file mode 100644
index 00000000..266df554
--- /dev/null
+++ b/tools/quantization/Utils.hpp
@@ -0,0 +1,17 @@
+#ifndef UTILS_H
+#define UTILS_H
+
+#include <sys/stat.h>
+
+const float IMAGENET_DEFAULT_MEAN[3] = {0.485f, 0.456f, 0.406f};
+const float IMAGENET_DEFAULT_STD[3]  = {0.229f, 0.224f, 0.225f};
+
+void load_image(
+    const std::string& img_path,
+    float *input_tensor,
+    std::string model,
+    int input_size,
+    int batch_size
+);
+
+#endif // UTILS_H
diff --git a/tools/quantization/calibration.cpp b/tools/quantization/calibration.cpp
index 5169ac56..2efc5c09 100644
--- a/tools/quantization/calibration.cpp
+++ b/tools/quantization/calibration.cpp
@@ -110,6 +110,9 @@ Calibration::Calibration(MNN::NetT* model, const uint8_t* modelBuffer, const int
         if (picObj.HasMember("center_crop_w")) {
             _preprocessConfig.centerCropWidth = picObj["center_crop_w"].GetFloat();
         }
+        if (picObj.HasMember("name")) {
+            _preprocessConfig.modelName = picObj["name"].GetString();
+        }
         if (picObj.HasMember("width")) {
             _width = picObj["width"].GetInt();
             _preprocessConfig.targetWidth = _width;
@@ -297,6 +300,7 @@ void Calibration::_resizeIfNeeded(std::string filename, bool force) {
     std::vector<int> inputShape = _getInputShape(filename);
     
     if ((inputShape != _inputTensorDims && _featureQuantizeMethod == "KL") || force) {
+        for (int i: _inputTensorDims) std::cout << i << " "; std::cout << std::endl;
         _inputTensorDims = inputShape;
         _interpreter->resizeTensor(_inputTensor, _inputTensorDims);
         _interpreter->resizeSession(_session);
